<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="styles.css">
	<title>Rust Basic Documentation</title>
</head>

<body>
	<nav id="navbar">
		<header>Rust</header>
		<ul>
			<li><a class="nav-link" href="#Introduction">Introduction</a></li>
			<li><a class="nav-link" href="#What_You_Should_Already_Know">What You Should Already Know</a></li>
			<li><a class="nav-link" href="#Installation">Installation</a></li>
			<li><a class="nav-link" href="#Hello_World">Hello World</a></li>
			<li><a class="nav-link" href="#Variables">Variables</a></li>
			<li><a class="nav-link" href="#Functions">Functions</a></li>
			<li><a class="nav-link" href="#Statements">Statements</a></li>
			<li><a class="nav-link" href="#Reference">Reference</a></li>
		</ul>
	</nav>
	<main id="main-doc">
		<section id="Introduction" class="main-section">
			<header>Introduction</header>
			<article>
				<p>Rust is a programming language that's focused on safety, speed, and concurrency. Its design lets you create programs that have the performance and control of a low-level language, but with the powerful abstractions of a high-level language. These properties make Rust suitable for programmers who have experience in languages like C and are looking for a safer alternative, as well as those from languages like Python who are looking for ways to write code that performs better without sacrificing expressiveness.</p>
				<p>Rust performs the majority of its safety checks and memory management decisions at compile time, so that your program's runtime performance isn't impacted. This makes it useful in a number of use cases that other languages aren't good at: programs with predictable space and time requirements, embedding in other languages, and writing low-level code, like device drivers and perating systems. It's also great for web applications: it powers the Rust package registry site, crates.io! We're excited to see what you create with Rust.</p>
			</article>
		</section>

		<section id="What_You_Should_Already_Know" class="main-section">
			<header>What You Should Already Know</header>
			<article>
				<p>This documentation is written for a reader who already knows how to programin at least one programming language. This documentation provide a useful guide to perform simple task and work with control flow statements that are available in almost all programming languages. We'll be learning Rust through small, focused examples that build on each other to demonstrate how to use various features of Rust as well as how they work behind the scenes.</p>
				<p>Note: This documentation assumes basic familiarity with the command line. Rust itself makes no specific demands about your editing, tooling, or where your code lives, so if you preferan IDE to the command line, feel free to use your favorite IDE.</p>
			</article>
		</section>

		<section id="Installation" class="main-section">
			<header>Installation</header>
			<article>
				<p>The first step to using Rust is to install it. You'll need an internet connection to run the commands in this chapter, as we'll be downloading Rust from the internet.</p>
				<h4>Installing on Linux or Mac</h4>
				<p>If you're on Linux or a Mac, all you need to do is open a terminal and type this:</p>
				<code class="snippet">
					curl https://sh.rustup.rs -sSf | sh
				</code>
				<p>This will download a script and start the installation. You may be prompted for your password. If it all goes well, you'll see this appear:</p>
				<samp class="snippet">Rust is installed now. Great!</samp>
				<p>Of course, if you disapprove of the curl | sh pattern, you can download, inspect and run the script however you like.</p>
				
				<h4>Installing on Windows</h4>
				<p>On Windows, go to <a href="https://rustup.rs">https://rustup.rs</a> and follow the instructions to download <code>rustup-init.exe</code>. Run that and follow the rest of the instructions it gives you.</p>
				<p>The rest of the Windows-specific commands in the book will assume that you are using cmd as your shell. If you use a different shell, you may be able to run the same commands that Linux and Mac users do. If neither work, consult the documentation for the shell you are using.</p>
				</article>
			</section>

			<section id="Hello_World" class="main-section">
				<header>Hello World</header>
				<article>
					<p>Now that you have Rust installed, let's write your first Rust program. It's traditional when learning a new language to write a little program to print the text “Hello, world!” to the screen, and in this section, we'll follow that tradition.</p>
					<p>First, make a directory to put your Rust code in. Rust doesn't care where your code lives, but for this documentation, we'd suggest making a projects directory in your home directory and keeping all your projects there. Open a terminal and enter the following commands to make a directory for this particular project:</p>
					<p>Linux and Mac:</p>
					<code class="snippet s-30">
						mkdir ~/projects<br>
						cd ~/projects<br>
						mkdir hello-world<br>
						cd hello-world<br>
					</code>
					<p>Windows:</p>
					<code class="snippet s-30">
						mkdir %USERPROFILE%\projects<br>
						cd %USERPROFILE%\projects<br>
						mkdir hello-world<br>
						cd hello-world<br>
					</code>
					<h4>Witing and Running a Rust Program</h4>
					<p>Next, make a new source file and call it main.rs. Rust files always end with the .rs extension. If you're using more than one word in your filename, use an underscore to separate them. For example, you'd use hello_world.rs rather than helloworld.rs.</p>
					<p>Now open the main.rs file you just created, and type the following code:<br>
					<code>Filename: main.rs</code></p>
					<code class="snippet s-30">
						fn main() {<br>&emsp;println!("Hello, world!");<br>}
					</code>
					<p>Save the file, and go back to your terminal window. On Linux or OSX, enter the following commands:</p>
					<code class="snippet s-30">
						rust main.rs<br>
						./main<br>
					</code>
					<samp class="snippet s-30">Hello, world!</samp>
					<p>On Windows, run <code>.\main.exe</code> instead of <code>.\main</code>. Regardless of your operating system, you should see the string <samp>Hello, world!</samp> print to the terminal. If you did, then congratulations! You've officially written a Rust program. That makes you a Rust programmer! Welcome!</p>
				</article>
			</section>

			<section id="Variables" class="main-section">
				<header>Variables</header>
				<article>
					<p>Every value in Rust is of a certain data type, which tells Rust what kind of data is being specified so it knows how to work with that data. We'll look at two data type subsets: scalar and compound.</p>
					<p>Next is a list with all data types in Rust. For this documentation, we'll only see some of them.</p>
					<ul>
						<li>Scalar Type</li>
						<ul>
							<li>Integer</li>
							<li>Floating-Point</li>
							<li>Boolean</li>
							<li>Character</li>
						</ul>
						<li>Compound Type</li>
						<ul>
							<li>Tuples</li>
							<li>Arrays</li>
						</ul>
					</ul>
					<p>Keep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time. The compiler can usually infer what type we want to use based on the value and how we use it.</p>
					<h4>Scalar Types</h4>
					<p>A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages.</p>
					<h5>Integer Types</h5>
					<p>An integer is a number without a fractional component. For example, for us to use one integer type, we use the <code>u32</code> type. This type declaration indicates that the value it's associated with should be an unsigned integer (signed integer types start with i instead of u) that takes up 32 bits of space. The following table shows the built-in integer types in Rust. We can use any of these variants to declare the type of an integer value.</p>
					<table>
						<thead>
							<tr>
								<th>Length</th>
								<th>Signed</th>
								<th>Unsigned</th>
							</tr>
						</thead>
						<tbody>
						<tr>
							<td>8-bit</td>
							<td><code>i8</code></td>
							<td><code>u8</code></td>
						</tr>
						<tr>
							<td>16-bit</td>
							<td><code>i16</code></td>
							<td><code>u16</code></td>
						</tr>
						<tr>
							<td>32-bit</td>
							<td><code>i32</code></td>
							<td><code>u32</code></td>
						</tr>
						<tr>
							<td>64-bit</td>
							<td><code>i64</code></td>
							<td><code>u64</code></td>
						</tr>
						<tr>
							<td>128-bit</td>
							<td><code>i128</code></td>
							<td><code>u128</code></td>
						</tr>
						<tr>
							<td>arch</td>
							<td><code>isize</code></td>
							<td><code><code>usize</code></td>
						</tr>
					</tbody>
					</table>
					<p>Each variant can be either signed or unsigned and has an explicit size. Signed and unsigned refer to whether it's possible for the number to be negative—in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned). It's like writing numbers on paper: when the sign matters, a number is shown with a plus sign or a minus sign; however, when it's safe to assume the number is positive, it's shown with no sign.</p>
					<p>Additionally, the <code>isize</code> and <code>usize</code> types depend on the architecture of the computer your program is running on, which is	denoted in the table as “arch”: 64 bits if you're on a 64-bit architecture and 32 bits if you're on a 32-bit architecture.</p>
					<h5>Floating-Point Types</h5>
					<p>Rust also has two primitive types for floating-point numbers, which are numbers with decimal points. Rust's floating-point types are <code>f32</code> and <code>f64</code>, which are 32 bits and 64 bits in size, respectively. The default type is <code>f64</code> because on modern CPUs, it's roughly the same speed as <code>f32</code> but is capable of more precision. All floating-point types
					are signed.</p>
					<p>Declaration of floating-point types are as follows:</p>
					<code class="snippet s-30">
						fn main() {<br> &emsp;let x = 2.0; //f54<br> &emsp;let y: f32 = 3.0; //f32 <br>}
					</code>
					<h5>The Boolean Type</h5>
					<p>As in most other programming languages, a Boolean type in Rust has two possible values: <code>true</code> and <code>false</code>. Booleans are one byte in size. The Boolean type in Rust is specified using <code>bool</code>. For example:</p>
					<code class="snippet s-50">
						fn main() {<br> &emsp;let t = true;<br> &emsp;let f: bool = false; // with explicit type annotation<br>}
					</code>
					<h4>Compound Types</h4>
					<p>Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.</p>
					<h5>The Tuple Type</h5>
					<p>A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</p>
					<p>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don't have to be the same. We've added optional type annotations in this example:</p>
					<code class="snippet">
						fn main() {<br> &emsp;let tup = {500, 6.4, 1};<br> &emsp;let {x, y, z} = tup;<br>&emsp;println!("The value of y is: {y}");<br>}
					</code>
					<p>This program first creates a tuple and binds it to the variable <code>tup</code>. It then uses a pattern with let to take <code>tup</code> and turn it into three separate variables, <code>x, y,</code> and <code>z</code>. This is called destructuring because it breaks the single tuple into three parts. Finally, the program prints the value of <code>y</code>, which is <code>6.4</code>.</p>
					<h5>The Array Type</h5>
					<p>Another way to have a collection of multiple values is with an array. Unlike a tuple, every element of an array must have the same type. Unlike arrays in some other languages, arrays in Rust have a fixed length.</p>
					<p>We write the values in an array as a comma-separated list inside square brackets:</p>
					<code class="snippet s-30">
						fn main() {<br> &emsp;let a = [1, 2, 3, 4, 5];<br>}
					</code>
					<p>Arrays are more useful when you know the number of elements will not need to change. For example, if you were using the names of the month in a program, you would probably use an array rather than a vector because you know it will always
					contain 12 elements:</p>
					<code class="snippet s-50">
						fn main() { <br> &emsp;let months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]; <br>}
					</code>
				</article>
			</section>

			<section id="Functions" class="main-section">
				<header>Functions</header>
				<article>
					<p>In Rust, function are declared with the <em>fn</em> keyword. Rust code uses snake case as the conventional style for function and variable names. In snake case, all letters are lowercase and underscores separate words. Here's a program that contains an example function definition:
					</p>
					<code class="snippet">
						fn main() {<br> &emsp;println!("Hello, World!");<br> &emsp;another_function(); <br>}
						<br><br> fn another_function() {<br>&emsp;println!("Another function.");<br>}
					</code>
					<p>Function definitions in Rust start with fn and have a set of parentheses
					after the function name. The curly braces tell the compiler where the
					function body begins and ends.</p>
					<h5>Function Parameters</h5>
					<p>Functions can also be defined to have <em>parameters</em>, which are special variables that are part of a function's signature. When a function has parameters, we can provide it with concrete values for those parameters. Technically, the concrete values are called <em>arguments</em>, but in casual conversation people tend to use the words “parameter” and “argument” interchangeably for either the variables in a function's definition or the concrete values passed in when you call a function.</p>
					<p>The following rewritten version of another_function shows what parameters look like in Rust:</p>
					<code class="snippet s-50">
						fn main() {<br> &emsp;another_function(5); <br>}
						<br><br> fn another_function(x: i32) {<br>&emsp;println!("The value of x is: {}.", x);<br>}
					</code>
				</article>
			</section>

			<section id="Statements" class="main-section">
					<header>Statements</header>
					<article>
						<p>We've actually already used statements and expressions. <em>Statements</em> are instructions that perform some action and do not return a value. <em>Expressions</em> evaluate to a resulting value. Let's look at some examples.</p>
						<p>Creating a variable and assigning a value to it with the <code>let</code> keyword is a statement.</p>
						<code class="snippet s-30">
							fn main() {<br> &emsp;let y = 6; <br>}
						</code>
						<p>Function definitions are also statements; the entire preceding example is a statement in itself.</p>
						<p>Statements do not return values. Therefore, you can't assign a let statement to another variable, as the following code tries to do:</p>
						<code class="snippet s-30">
							fn main() {<br> &emsp;let x = (let y = 6);<br>}
						</code>
						<p>When you run this program, you'll get an error like this:</p>
						<samp class="snippet s-50">
							error: expected expression, found statement (`let`) <br>note: variable declaration using `let` is a statement
						</samp>
						<p>The <code>let y = 6</code> statement does not return a value, so there isn't anything for <code>x</code> to bind to. This is different than in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write <code>x = y = 6</code> and have both <code>x</code> and <code>y</code> have the value <code>6;</code> that is not the case in <em>Rust</em>.</p>
						<p>Expressions evaluate to something and make up most of the rest of the code that you'll write in Rust.Consider a simple math operation,such as <code>5 + 6</code>, which is an expression that evaluates to the value 11. Expressions can be part of statements: in previus example that had the statement <code>let y = 6;</code>, <em>6</em> is an expression that evaluates to the value <em>6</em>. <em>Calling a function is an expression. Calling a macro is an expression.</em> The block that we use to create new scopes, <em>{}</em>, is an expression, for example:</p>
						<code class="snippet">
							fn main() {
							<br> &emsp;let x = 5;
							<br> &emsp;let y = {
								<br> &emsp;&emsp;let x = 3;
								<br> &emsp;&emsp;x + 1;
							<br>};
							<br><br> &emsp;println!("The value of y is: {}", y);
							<br>}
						</code>
						<p>This expression:</p>
						<code class="snippet s-30">
							{
							<br> &emsp;let x = 3;
							<br> &emsp;x + 1;
							<br>}
						</code>
						<p>is a block that, in this case, evaluates to <code>4</code>. That value gets bound to <code>y</code> as part of the <code>let</code> statement. Note the line without a semicolon at the end, unlike most of the lines you've seen so far. Expressions do not include ending semicolons. <em>If</em> you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.</p>
					</article>
			</section>

			<section id="Reference" class="main-section">
				<header>Reference</header>
				<article>
					<p>This basic documentation was built using the actual Rust documentation, available in the next link:</p>
					<ul>
						<li><a href="https://doc.rust-lang.org/book/title-page.html">The Rust Programming Language</a>, by Steve Klabnik and Carol Nichols, with contributions from the Rust Community</li>
					</ul>
					For a more deep and complete documentation, please do not hesitate diving deep.
				</article>
			</section>

	</main>
</body>

</html>